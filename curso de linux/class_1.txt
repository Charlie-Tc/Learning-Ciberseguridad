            LINUX
Linux es un sistema operativo de còdigo abierto y gratuito que forma parte de la familia Unix.
Se caracteriza por su estabilidad, seguridad y flexibilidad, y se utiliza en una amplia variedad de dispositivos y servidores.
Linux se basa en el kernel de Linux, que es el nùcleo del sistema, y puede ser personalizado y modificado por la comunidad de los desarrolladores.



3 TIPOS DE USUARIOS

# Usuario root o administrador: El usuario root es el administrador principal del sistema Linux y tiene acceso completo a todas las funciones y recursos. Pueden realizar tareas de administraciòn, instalar sotware, configurar el sistema y realizar cambios crìtivos.
# Usuarios normales o de trabajo: Los usuarios normales son aquellos que utilizan el sistema para tareas cotidianas y de trabajo. Tienen permisos limitados y no pueden realizar cambios fundamentales en el sistema.
# Usuarios especiales o de sistema: Los usuarios especiales son cuentas creadas para que los servicios y aplicaciones del sistema pueden acceder a recursos especìficos. Su propòsito es garantizar la seguridad y el aislamiento de los servicios del sistema.

DIRECTORIOS DE LINUX
/ : Root o principal. Punto de acceso al sistema de ficheros.
/bin : Ejecutables o ficheros binarios.
/dev : dispositivos. Contiene los ficheros que se comunican con los distintos dispositivos del sistema.
/etc : Ficheros de configuraciòn y diversos scripts.
/home : Directorios personales de los usuarios.
/lib : Librerìas del sistema.
/media : Para el montaje de dispositivos extraìbles.
/mnt : Para montar sistemas de ficheros.
/opt : Para isntalar sotware externo.
/proc : Informaciòn sobre el estado del sistema, dispositivos y procesos.
/root : Directorio HOME del usuario ROOT.
/sbin : Otros binarios.
/tmp : Ficheros y directorios temporales.
/usr : Aplicacionesy archivos varios.
/var/ : Ficheros de logs, trazas y otros ficheros dinàmicos.

METACHARACTER(S)
Son caràcteres especiales que tienen un significado especial en el contexto de la lìnea de comandos de linux y se utilizan para realizar tareas como bùsqueda,
coincidencia de patrones, redirecciòn  y màs. som:

# * (Asterisco): Se utiliza para hacer coincidir cero o más caracteres en nombres de archivos o directorios. Por ejemplo, *.txt coincidiría con todos los archivos que terminan en ".txt".
# ? : (Signo de interrogación): Se utiliza para hacer coincidir un solo carácter en nombres de archivos o directorios. Por ejemplo, archivo?.txt coincidiría con "archivo1.txt" y "archivo2.txt", pero no con "archivo10.txt".
# [] : (Corchetes): Se utiliza para hacer coincidir un solo carácter de una lista de caracteres posibles. Por ejemplo, [aeiou] coincidiría con cualquier vocal, y [0-9] coincidiría con cualquier dígito.
# | : (Barra vertical): Se utiliza para realizar una operación "o" en comandos. Por ejemplo, comando1 | comando2 redirige la salida del "comando1" a la entrada del "comando2".
# > : (Mayor que): Se utiliza para redirigir la salida de un comando a un archivo. Por ejemplo, comando > archivo.txt guarda la salida del "comando" en "archivo.txt" (sobrescribe el archivo si ya existe).
# >> : (Doble mayor que): Similar a >, pero agrega la salida al final de un archivo en lugar de sobrescribirlo. Por ejemplo, comando >> archivo.txt agrega la salida al final de "archivo.txt".
# < : (Menor que): Se utiliza para redirigir la entrada de un comando desde un archivo. Por ejemplo, comando < archivo.txt toma la entrada del "comando" desde "archivo.txt".
# ; : (Punto y coma): Se utiliza para separar múltiples comandos en una sola línea de comando. Por ejemplo, comando1 ; comando2 ejecuta "comando1" y luego "comando2".
# (): (Paréntesis): Se utiliza para agrupar comandos y controlar el orden de ejecución. Por ejemplo, (comando1 ; comando2) ejecuta "comando1" y luego "comando2" en un subshell.
# & : (Ampersand): Se utiliza para ejecutar un comando en segundo plano, lo que permite que la línea de comandos esté disponible para la entrada de más comandos mientras el comando en segundo plano se ejecuta.



COMANDOS:

* pwd : Sirve para mostrar la ruta de directorio actual.
* ls : Lista todos los archivos y directorios del directorio actual.
    ** ls -l: lista detalladamente los archivos y directorios, como sus permisos, propietario, tamaño, etc.
    ** ls -a : muestra archivos ocultos que comienzan con un punto(puede ser archivos de configuraciòn).
    ** ls -h : muestra tamaños de archivos en un formato legible por humanos(por ejemplo, "1.2M").
    ** ls -R : lista los archivos y directorios de manera recursiva, incluyendo subdirectorios.
    ** ls -t: Ordena los archivos y directorios por fecha y hora de modificación, mostrando primero los más recientes.
    ** ls -r: Lista los archivos y directorios en orden inverso, es decir, desde el último hasta el primero.
    ** ls -S: Ordena los archivos y directorios por tamaño, mostrando primero los más grandes.
    ** ls -i: Muestra los números de inodo de los archivos y directorios, que son identificadores únicos del sistema de archivos.
    ** ls -1: Lista los archivos y directorios en una sola columna, uno por línea, útil para una salida más simple.
    ** ls -G: Muestra la salida en color, lo que facilita la identificación de archivos y directorios.
    ** ls -lha: Muestra una lista detallada, incluyendo archivos ocultos y con tamaños legibles por humanos.   
    ** ls -ltr: Lista archivos y directorios en orden inverso y ordenados por fecha y hora de modificación. 
    ** ls -alh: Muestra archivos legibles para el usuario.
* cd : Cambiar al directorio personal del usuario.
    ** cd / : Cambiar al directorio raiz.
    ** cd .. : Cambiar al directorio anterios.
    ** cd ~nombre_de_usuario: Cambiar al directorio de inicio de otro usuario.
    ** cd . : permanece en el directorio actual.
* man nombre_de_comands : muestra la paginas manuales de los comandos, programas y funcioens del sistema operativo.
* file file_name : Sirve para extraer informaciòn de un archivo.
* mkdir nombre_del_directorio : Este comando crearà un directorio con el nombre especìficado en el directorio actual.
    ** mkdir -p directorio1/directorio2/directorio3 : Esto crearà los directorios mencionados, junto son sus subdirectorios si no existen.
    ** mkdir -m 755 nombre_del_directorio : Esto establecerà permisos de lectura, escritura y ejecuciòn para el propietario, y permisos de lectura y ejecuciòn para otros usuarios en el directorio creado.
    ** mkdir dectorio1 directorio2 directorio3 : Esto crearà los directorios mencionado en el directorio actual.
    ** mkdir -o usuario -g grupo nombre_del_directorio : Esto establecerà el propietario como "usuario" y el grupo como "grupo" para el directorio creado.
    ** mkdir -d "2023-09-18 10:30" nombre_del_directorio : Esto establecerà la marca de tiempo del directorio en la fecha y hora especìficadas.
    ** mkdir -v 'directorio' : Utiliza un variante de mkdir para mostrar un mensaje informativo que indica què directorio se està creando.
* touch nombre_del_archivo : Esto crearà un archivo en directorio actual.
    ** touch file.txt file2.txt file3.txt : Crea varios archivos al mismo tiempo proporcionando una lista de nombres de archivos separados por espacios.
    ** touch archivo_existente.txt :  Sirve para actualizar su marca de tiempo sin modificar su contenido.
    ** touch -d "2023-09-15 14:30" file.txt : la opciòn -d sirve para especificar una marca de tiempo personalizada para un archivo.
    ** touch -r archivo_original.txt archivo_nuevo.txt : La opciòn -r seguidad del nombre de otro archivo para copiar las marcas de tiempo de ese archivo a un nuevo archivo.
    ** touch -c archivo.txt : La opciòn -c o --no-create permite verificar si un archivo existe antes de intentar crearlo. Si el archivo no existe, no se crearà.
    ** touch -t 202309151430 file.txt : La opciòn '-t' seguida de un formato especìfico de fecha y hora para establecer la marca de tiempo de un archivo.
* echo : se utiliza para imprimir texto o variables en la pantalla o redigir su salida hacia un archivo.
    ** echo "Hello, World" : El uso màs bàsico de 'echo' es imprimir texto en la pantalla.
    ** echo -n "Hola": La opciòn '-n' para imprimir texto sin un salto de lìnea al final
    ** echo -e "Lìnea 1\nLìnea 2\tTabulaciòn" : Interpreta secuencias de escape, como "\n" para nueva lìnea o "\t" para tabulaciòn.
    ** echo $mi_variable : Puedes usar 'echo' para imprimir el contenido de variables.
    ** echo "redirige el texto al archivo.txt" > archivo.txt : Puedes redigir la salida de 'echo' a un archivo utilizando el operador '>'.
    ** echo "Este es un mensaje" >> archivo.txt : Puedes usar '>>' para redijir la salida de 'echo' y agregar el contenido al final de un archivo existente en lugar de sobreescribirlo.
    ** echo "Error" 2>error.txt : Puedes usar '2>' para redigir la salida de error de 'echo' a un archivo.
    ** echo "Mensaje" > salida.txt 2>&1 : Puedes combinar la salida estàndar y de error en un solo archivo utilizando '2>&1'.
* cat : Se utiliza principalmente para mostrar el contenido de archivos de texto en la terminal.
    ** cat archivo.txt : El uso màs bàsico de 'cat' es mostrar el contenido de un archivo en la pantalla.
    ** cat file.txt file2.txt file3.txt : Muestra el contenidode varios archivos.
    ** cat file.txt file2.txt > archivo_concatenado.txt : Se utiliza comùnmente para concatenar el contenido de varios archivos en un solo.
    ** cat -n file.txt : La opciòn '-n' para numerar las lìneas de salida.
    ** tac file.txt : La opciòn 'r' para mostrar el contenido del archivo en sentido inverso, es decir, desde el final al principio.
    ** cat file.txt | grep "patròn" : Puede usar 'cat' junto con otras herramientas como 'grep' o 'sed' para mostrar solo las lìneas que coincidan con un patròn especìfico en un archivo.
    ** zcat : cat se puede usar junto con otras herramientas como 'zcat' o 'bzcat' para mostrar el contenido de archivos comprimidos.
* cp : Se utiliza para copiar archivos y directorios.
    ** cp archivo_origen archivo_destino : El uso màs bàsico de 'cp' es copiar un archivo a otro destino.
    ** cp file.txt file2.txt directorio_destino/ : Copia varios archivos en un directorio especìfico proporcionado una lista de archivos de origen seguidos por el directorio de destino.
    ** cp -r directorio_origen/ directorio_destino/ : Copia un directorio y su contenido utilizando la opciǹ '-r' o 'R'.
    ** cp -rp directorio_origen/ directorio_destino/ : La opción -p para preservar los atributos, marcas de tiempo y permisos de los archivos y directorios al copiarlos.
    ** cp -i archivo_origen archivo_destino : or defecto, cp no sobrescribe archivos existentes en el destino. Puedes utilizar la opción -i para que cp te pregunte antes de sobrescribir archivos existentes. 
    ** cp -f archivo_origen archivo_destino :  La opción -f para forzar la copia, sobrescribiendo archivos en el destino sin preguntar.
    ** cp -v archivo_origen archivo_destino : La opción -v (que significa "verbose") muestra información detallada sobre los archivos copiados mientras se realiza la operación. 
    ** cp -s archivo_origen archivo_destino : La opción -s para preservar los enlaces simbólicos al copiar archivos y directorios.
* mv : Sirve para mover o renombrar archivos y directorios.
    ** mv archivo_origen archivo_destino : El uso màs bàsico de 'mv' es mover un archivo a otro destino.
    ** mv file.txt file2.txt directorio_destino/ : Mueve varios archivos a un directorio especìfico.
    ** mv archivo_antiguo.txt archivo_nuevo.txt : Usa 'mv' para cambiar el nombre de un archivo o directorio al mismo tiempo que lo mueves.
    ** mv -t directorio_destino/ directorio_origen/ : Puedes mover un directorio y su contenido utilizando la opción -t (que significa "target" o destino). 
    ** mv -f archivo_origen archivo_destino : uedes utilizar la opción -f para forzar la acción, lo que significa que mv sobrescribirá archivos existentes en el destino sin preguntar.
    ** mv -p archivo_origen archivo_destino : Puedes utilizar la opción -p para preservar los atributos, marcas de tiempo y permisos de los archivos y directorios al moverlos. 
    ** mv mv -v archivo_origen archivo_destino : La opción -v (que significa "verbose") muestra información detallada sobre los archivos y directorios movidos mientras se realiza la operación.
    ** mv mv -n archivo_origen archivo_destino : or defecto, mv no sobrescribe archivos existentes en el destino. Puedes utilizar la opción -n para evitar que mv sobrescriba archivos.
* rmdir : Se utiliza para eliminar directorios y archivos.
    ** rmdir nombre_del_directorio : El uso más básico de rmdir es simplemente proporcionar el nombre del directorio que deseas eliminar. 
    ** rmdir directorio1 directorio2 directorio3 : uedes eliminar varios directorios vacíos al mismo tiempo proporcionando una lista de nombres de directorios separados por espacios. 
    ** rm -r directorio_no_vacio/ : Si deseas eliminar un directorio y su contenido (incluso si no está vacío), debes usar el comando rm en lugar de rmdir. 
    ** rmdir -p directorio_padre/directorio_hijo : La opción -p para eliminar un directorio y todos sus directorios padres que estén vacíos.
    ** rmdir -i directorio_vacio : Puedes usar la opción -i para que rmdir te pregunte antes de eliminar cada directorio. Esto es útil para evitar la eliminación accidental.
* tail : Se utiliza principalmente para mostrar las ùltimas lìneas de un archivo de texto en la terminal.
    ** tail archivo.txt : El uso màs bàsico de 'tail' es simplemente proporcionar el nombre del archivo.
    ** tail -n 30 archivo.txt : La opciòn '-n' seguida de un nùmero para especificar cuàntas lìneas quieres mostrar.
    ** tail -f archivo.txt : puedes utilizar la opciòn 'f' para mostrar las nuevas lìneas que se agregan al archivo en tiempo real.
    ** tail -c 100 archivo.txt : La opciòn '-c' seguida de un nùmero para mostrar las ùltimas lìneas desde una posiciòn especìfica en bytes.
    ** tail -r file.txt : La opciòn '-r' para mostrar las lìneas en orden inverso, es decir, desde la ùltima lìnea hasta la primera.
    ** tail file.txt file2.txt : Puedes proporcionar una lista de nombres de arhcivos separados por espacios para ver las ùltimas lìneas de varios archivos al mismo tiempo.
* head : Se utilza principalmente para mostrar las primeras lineas de un texto en la terminal.
    ** head file.txt : Muestra la primeras lìneas del archivo.
    ** head -n 5 file.txt : Muestra la primeras 5 lìneas del archivo.
* less file.txt : Se utilza para visualizar archivos de texto uno a la vez, lo que facilita la navegaciòn y la lectura de archivos largos.
* tree : El uso más básico de tree es simplemente ejecutarlo sin opciones.
    ** tree -L 2 : Puedes utilizar la opción -L seguida de un número para limitar la profundidad a la que se muestra la estructura de directorios.
    ** tree -d : Mostrar solo directorios
    ** tree -f : Mostrar solo archivos
    ** tree -P "*.txt" : Puedes utilizar la opción -P seguida de un patrón para mostrar solo los archivos y directorios que coincidan con ese patrón.
    ** tree -p : Puedes utilizar la opción -p para mostrar los permisos y propietarios de cada archivo y directorio en la estructura. 
    ** tree -a : Puedes utiliPuedes utilizar la opción -s para mostrar los tamaños de archivo y directorio en la estructura.
    ** tree > estructura.txt : Puedes redirigir la salida de tree a un archivo de texto utilizando el operador >.
* who : Se utiliza para mostrar informaciòn sobre los usuarios que estàn actualmente conectados al sistema.
    ** who -l : Puedes utilizar la opción -l (que significa "long" o larga) para mostrar información adicional sobre los usuarios, como su dirección IP y el nombre de la máquina desde la que se conectaron. 
    ** who -q : Puedes utilizar la opción -q (que significa "quick" o rápido) para mostrar solo los nombres de usuario de los usuarios conectados, sin información adicional. 
    ** who -lq : Puedes combinar las opciones -l y -q para mostrar información detallada pero en un formato más compacto. 
    ** who usuario1 : uedes proporcionar el nombre de usuario como argumento para who para ver información sobre un usuario específico.
    ** who -f /var/log/wtmp : Puedes utilizar la opción -f seguida de la ubicación de un archivo de registro para mostrar información sobre usuarios conectados desde ese archivo de registro.
    ** who --dead : Puedes utilizar la opción --dead para mostrar solo usuarios que han desconectado sus sesiones. 
* ln : Se utiliza para crear enlaces(simbòlicos o duros) entre archivos y directorios.
    ** ln -s archivo_o_directorio enlace_simbolico : El uso màs bàsico de 'ln' para crear un enlace simbòlico es proporcionar el nombre del archivo o directorio de destino y el nombre del enlace simbòlico que deseas crear.
    ** ln archivo_o_directorio enlace_duro : Para crear un enlace duro, simplemente proporciona el nombre del archivo o directorio de destino y el nombre del enlace duro que deseas crear.
    ** ln -sf archivo_o_directorio enlace_simbolico : Puedes utilizar la opciòn '-f' para forzar la creaciòn de enlaces incluso si el enlace simbòlico o enlace duro ya existe.
    ** ln archivo_o_directorio directorio_destino/ : Puedes especificar un directorio de destino en lugar de un nombre de enlace simbòlico o enlace duro. Esto crearà el enlace en ese directorio con el mismo nombre que el archivo o directorio de origen.
* ls -i [directorio] : Se utiliza para mostrar la lista de archivos y directorios en un directorio junto con sus nùmeros de nodo ¡Node.
* du : Se utiliza  para mostrar el uso del espacio en disco de archivos y directorios. 
    ** du -h : Muestra el uso del espacio en disco de forma legible para el ser humano es decir con tamaños en formato legible como KB, MB o GB.
    ** du -s : Muestra el uso total del espacio en disco de un directorio sin listar el detalle de cada subdirectorio.
    ** du -c : Muestra el uso del espacio en disco de cada subdirectorio y al final muestra un total acumulado.
    ** du -a : Muestra el uso del espacio en disco de archivos y directorios por separado.
    ** du -d N : Limita la profundidad de la bùsqueda hasta N niveles de subdirectorios. por ejemplo, du -d 2 mostrarà solo el uso del espacio en disco hasta un màximo de dos niveles de subdirectorios.
    ** du --max-depth=N: Limita la profundidad de bùsqueda.
    ** du -k : Muestra el uso del espacio en disco en kilobytes en lugar de bloques de disco.
    ** du -m : Muestra el uso del espacio en disco en megabytes.
    ** du -g : Muestra el uso del espacio en disco en gigabytes.
    ** du -h --max-depth=1 | sort -hr : Muestra el uso delespacio en disco de los subdirectorios del directorio actual en un formato legible para humanos y lo ordena en orden descendente para mostrar los directorios mas grandes primero.
* df :  El uso más básico de df es simplemente ejecutarlo sin opciones.
    ** df -h : Puedes utilizar la opción -h (que significa "human-readable" o "legible para humanos") para mostrar los tamaños en un formato más fácil de entender, como gigabytes (GB) y megabytes (MB).
    ** df /ruta/al/sistema_de_archivos : Puedes proporcionar el nombre de un sistema de archivos como argumento para df para ver información específica sobre ese sistema de archivos.
    ** df -l : Puedes utilizar la opción -l (que significa "local" o "solo sistemas de archivos locales") para mostrar solo sistemas de archivos locales en lugar de sistemas de archivos de red o remotos.
    ** df -i : Puedes utilizar la opción -i para mostrar el número de inodos en lugar de bloques en el sistema de archivos. Los inodos son estructuras de datos utilizadas por el sistema de archivos para almacenar información sobre archivos y directorios.
    ** df -T : Puedes utilizar la opción -T para mostrar el tipo de sistema de archivos de cada sistema de archivos montado. Esto te proporcionará información sobre si un sistema de archivos es ext4, NTFS, etc
    ** df -x ext4 : Puedes utilizar la opción -x seguida de un tipo de sistema de archivos para mostrar solo sistemas de archivos de ese tipo.
* history : Sirve para ver una lista de comando ejecutados por el usuario.
    ** !5 : Puedes ejecutar un comando previo del historial utilizando el formato !n, donde "n" es el número de línea del comando en el historial.
    ** !! : Puedes ejecutar el último comando ejecutado utilizando !!. 
    ** !ls :Ejecutar un comando que coincida con un patrón específico: Puedes usar !patrón para ejecutar el último comando que coincida con un patrón específico. Por ejemplo, si deseas ejecutar el último comando que comienza con "ls".
    ** history -c : Puedes borrar todo el historial de comandos utilizando el comando history -c.
    ** history > file.txt : Puedes exportar el historial de comandos a un archivo de texto utilizando el comando history > archivo.txt. Esto te permite guardar el historial en un archivo para referencia futura.
    ** history -r : Puedes recargar el historial de comandos actual en la sesión actual utilizando history -r. Esto puede ser útil si has editado manualmente el archivo de historial y deseas reflejar esos cambios en la sesión actual.
    ** history -n : Puedes usar history n para ver los últimos "n" comandos ejecutados en el historial. Por ejemplo, history 10 mostrará los últimos 10 comandos ejecutados.
    ** history | grep buscar : Puedes buscar comandos específicos en el historial utilizando el comando history | grep patrón. Por ejemplo, para buscar comandos que contengan la palabra "buscar".
    ** history -d numero_de_comando : Borra el comando de la lista de historial.
* gedit archivo.txt : Puedes abrir un archivo específico en gedit proporcionando su ruta como argumento al comando gedit.
    ** gedit & : Puedes simplemente ejecutar gedit en la terminal para abrir una nueva ventana de gedit. Si deseas abrir gedit en segundo plano (para seguir usando la terminal), puedes agregar un ampersand & al final.
    ** sudo gedit /etc/archivo_de_configuracion : Si necesitas editar archivos que requieren permisos de superusuario (por ejemplo, archivos en /etc), puedes usar sudo para abrir gedit con privilegios elevados.
    ** gedit --view archivo.txt : Puedes abrir un archivo en modo de solo lectura para evitar cambios accidentales utilizando la opción --view.
    ** gedit /ruta/completa/al/archivo.txt : Puedes abrir un archivo ubicado en una carpeta específica utilizando la ruta completa del archivo.
    ** Kill ID_de_proceso_gedit : Puedes cerrar una instancia de gedit desde la terminal utilizando el comando kill. Primero, obtén el ID de proceso de gedit utilizando ps aux | grep gedit, y luego usa kill para cerrarlo.
* ps : El uso más básico de ps es simplemente ejecutarlo sin opciones. Esto mostrará una lista de los procesos en ejecución para el usuario actual en la terminal actual.
    ** ps -e : Puedes utilizar la opción -e o -A para mostrar todos los procesos de todos los usuarios en el sistema.
    ** ps -l : Puedes utilizar la opción -l para mostrar información detallada sobre los procesos, incluidos los nombres de usuario, el estado del proceso, el uso de CPU y la memoria.
    ** ps -x : Puedes utilizar la opción -x para mostrar todos los procesos, incluidos aquellos que no están asociados a una terminal.
    ** ps -u usuario : Puedes utilizar la opción -u seguida del nombre de usuario para mostrar los procesos de un usuario específico.
    ** ps -G grupo : Puedes utilizar la opción -G seguida del nombre del grupo para mostrar los procesos de un grupo específico. 
    ** ps -H : Puedes utilizar la opción -H para mostrar todos los procesos en formato de árbol, lo que hace que sea más fácil ver la jerarquía de procesos y sus relaciones.
    **  ps -C programa : Puedes utilizar la opción -C seguida del nombre de un programa para mostrar procesos que corresponden a ese programa específico.
* type comando : Mostrar el tipo de un comando: El uso más básico de type es proporcionar el nombre del comando como argumento para mostrar cómo se interpretaría.
    ** type -a comando : Puedes utilizar la opción -a para mostrar todas las rutas de comandos disponibles para un comando. Esto es útil si hay varios comandos con el mismo nombre y quieres ver cuál se ejecutará primero según la ruta de búsqueda.
    ** type -p comando : Puedes utilizar la opción -p para mostrar solo la ruta de acceso al comando sin descripciones adicionales.
    ** type nombre_de_la_funcion : Si deseas obtener información sobre una función definida por el usuario, puedes proporcionar el nombre de la función como argumento.
    ** type nombre_del_alias : Sì deseas obtener información sobre un alias, puedes proporcionar el nombre del alias como argumento.
* which comando : El uso más básico de which es proporcionar el nombre del comando como argumento para mostrar la ruta completa de su ubicación.
    ** which -a comando : Puedes utilizar la opción -a para mostrar todas las ubicaciones en las que se encuentra un comando en caso de que existan múltiples instancias del mismo nombre en diferentes ubicaciones en la variable PATH.
    ** which --skip-alias  comando : Puedes utilizar la opción --skip-alias para mostrar solo la primera ubicación encontrada en caso de que el comando sea un alias. Esto es útil para evitar mostrar rutas múltiples si un comando es un alias que apunta a diferentes ubicaciones.
    ** which --all comando : Si deseas mostrar la ubicación de un comando sin verificar si es un alias, puedes utilizar la opción --all o -a junto con which. 
    ** which --help : Puedes obtener información sobre el uso de which y sus opciones utilizando la opción --help. 
* whereis comando : El uso más básico de whereis es proporcionar el nombre de un comando como argumento para buscar su ubicación en el sistema.
    ** whereis -b comando : Si solo deseas buscar la ubicación del archivo binario de un comando, puedes utilizar la opción -b. 
    ** whereis -m comando : Si solo deseas buscar la ubicación de las páginas de manual de un comando, puedes utilizar la opción -m.
    ** whereis -s comando : Si solo deseas buscar la ubicación de las fuentes de comandos de un comando (si están disponibles), puedes utilizar la opción -s. 
    ** whereis comando1 comando2 : Puedes buscar múltiples comandos al mismo tiempo proporcionando sus nombres como argumentos separados. 
    ** whereis --help : Puedes obtener información sobre el uso de whereis y sus opciones utilizando la opción --help.
* alias mi_alias="comando" : El uso más básico de alias es proporcionar el nombre del alias seguido del comando o secuencia de comandos que deseas abreviar.
    ** unalias mi_alias : Para eliminar un alias, puedes utilizar el comando unalias seguido del nombre del alias que deseas eliminar. 
    ** alias : Puedes listar todos los alias definidos en tu sesión actual utilizando el comando alias sin argumentos. 
    ** alias mi_alias : Si deseas ver la definición de un alias específico, puedes usar alias seguido del nombre del alias. 
    ** .bashrc o .bash_aliases : Si deseas que un alias esté disponible cada vez que inicies una nueva sesión, puedes agregar la definición del alias en tu archivo de inicio de sesión (como .bashrc o .bash_aliases). Esto asegurará que el alias esté disponible en futuras sesiones.
    ** alias --help : Puedes obtener información sobre el uso de alias y sus opciones utilizando el comando alias sin argumentos o con la opción --help.
* time comando : El uso más básico de time es preceder un comando con time.
    ** time comando > salida.txt : Puedes redirigir la salida de time a un archivo utilizando el operador de redirección >. 
    ** time comando1 | comando2 : Puedes utilizar time con pipelines para medir el tiempo de ejecución de una secuencia de comandos. 
    ** time : Puedes usar time para medir el tiempo de ejecución de scripts de shell o programas que escribas. Simplemente precede la llamada al script o programa con time.
    ** time -f "Tiempo real: %e segundos\nTiempo de CPU: %U segundos" comando : Puedes especificar el formato de salida de time utilizando la opción -f seguida de una cadena de formato. 
* cal : El uso más básico de cal es simplemente ejecutarlo sin opciones. Esto mostrará el calendario del mes actual en la terminal. 
    ** cal 5 2022 : Puedes mostrar el calendario de un mes y año específicos proporcionando el número del mes y el año como argumentos. 
    ** cal -y : Puedes utilizar la opción -y para mostrar un calendario anual completo. 
    ** cal -w : Puedes utilizar la opción -w para mostrar el número de la semana en el calendario. 
    ** cal 2023 : Si deseas mostrar el calendario completo de un año específico, puedes proporcionar solo el año como argumento. 
    ** val --version : Puedes usar la opción --version para mostrar la versión de cal. 
* ncal : Esti mostrarà el calendario del mes actual en la terminal.
* date : El uso más básico de date es simplemente ejecutarlo sin opciones. Esto mostrará la fecha y hora actual en la terminal.
    ** date +"%Y-%m-%d %H:%M:%S" : Puedes utilizar la opción + seguida de un formato personalizado para mostrar la fecha en un formato específico.
    ** sudo date -s "2023-09-18 15:30:00" : Puedes utilizar date con la opción -s seguida de una cadena de fecha y hora para configurar manualmente la fecha y hora del sistema. Esto generalmente requiere privilegios de superusuario (puedes usar sudo). 
    ** date -u : Puedes utilizar la opción -u para mostrar la fecha y hora en formato UTC (Tiempo Universal Coordinado). 
    ** date -d o date -t : Puedes utilizar opciones como -d para mostrar solo la fecha o -t para mostrar solo la hora.
    ** date -I America/New_York : Puedes utilizar la opción -I seguida del nombre de un huso horario para mostrar la fecha y hora en ese huso horario. 
    ** date +%s : Puedes utilizar la opción +%s para mostrar la fecha y hora en segundos desde la época Unix (1 de enero de 1970).
    ** date +%A : Puedes utilizar la opción +%A para mostrar el nombre completo del día de la semana. 
    ** date +%B : Puedes utilizar la opción +%B para mostrar el nombre completo del mes actual. 
    ** date +"%I:%M:%S %P" : Puedes utilizar la opción +%I:%M:%S %p para mostrar la hora en formato de 12 horas con AM/PM.
    ** date --iso-8601 : Puedes utilizar la opción --iso-8601 para mostrar la fecha y hora en formato ISO 8601. 
    ** date --rfc-2822 : Puedes utilizar la opción --rfc-2822 para mostrar la fecha y hora en formato RFC 2822. 
    ** date +%s%3N : Puedes utilizar la opción +%s%3N para mostrar la fecha y hora en milisegundos desde la época Unix.
* tr a e : En este caso la entrada es 'a', pero en la salida a la entrada lo cambia por e. 
    ** echo "texto" | tr 'a-z' 'A-Z' :Puedes utilizar la opción -c para especificar el conjunto de caracteres que deseas cambiar por otro conjunto de caracteres. 
    ** echo "hola" | tr -d 'aeiou' : Puedes utilizar la opción -d para eliminar caracteres específicos de la entrada. 
    ** echo "esto es un ejemplo" | tr -s ' ' : Puedes utilizar la opción -s para sustituir un conjunto de caracteres por un único carácter. 
    ** echo "a1b2c3d" | tr -cd '[:digit:]' : Puedes utilizar tr junto con [:class:] para eliminar caracteres no deseados. 
    ** echo "12345" | tr '0-9' 'X' : Puedes especificar un rango de caracteres utilizando el guion (-). 
    ** tr --help : Puedes obtener información sobre el uso de tr y sus opciones utilizando la opción --help. 
    ** echo "abcdef" | rev | tr -d '\n' : Puedes utilizar el comando rev junto con tr para revertir el orden de los caracteres en una línea. 
    ** echo "h0e!l#l$6" | tr -d -c '[:alpha:]' : Puedes utilizar una expresión regular para eliminar todos los caracteres no alfabéticos de una cadena.
    ** echo -e "Hola\tmundo" | tr .d '[:contrl: ] : Puedes utilizar tr para eliminar caracteres de control de una cadena, como tabulaciones y retornos de carro. 
* wc archivo.txt : El uso más básico de wc es contar líneas en un archivo o entrada proporcionada desde la terminal.
    ** wc -w archivo.txt : Puedes utilizar la opción -w para contar palabras en lugar de líneas. 
    ** wc -c archivo.txt : Puedes utilizar la opción -c para contar caracteres en lugar de líneas o palabras. 
    ** wc -l archivo.txt : Puedes utilizar la opción -l, -w, o -c para mostrar solo el recuento respectivo en un formato simple sin el nombre del archivo. 
        *** wc -l << fin : Este comando se utiliza para contar lìneas de texto mientra que la palabra fin no se indique en la entrada .
* cat document 2>/dev/null : mostrará el contenido del archivo "document" si existe en el directorio actual y descartará cualquier mensaje de error que se genere durante el proceso. Esto es útil si deseas mostrar el contenido de un archivo y no estás interesado en los mensajes de error que puedan surgir si el archivo no existe.
* uniq archivo.txt : El uso más básico de uniq es simplemente ejecutarlo sin opciones. Esto mostrará las líneas únicas de la entrada proporcionada. 
    ** uniq -d archivo.txt : Puedes utilizar la opción -d para mostrar solo las líneas que tienen duplicados. 
    ** uniq -c archivo.txt : Puedes utilizar la opción -c para contar las líneas duplicadas y mostrar el número de ocurrencias junto a cada línea. 
    ** uniq -s 3 archivo.txt : Puedes utilizar la opción -s seguida de un número para ignorar un número específico de caracteres al principio de cada línea antes de realizar la comparación. 
    ** uniq -f 2 archivo.txt : Puedes utilizar la opción -f seguida de un número para ignorar un número específico de campos delimitados por espacios al principio de cada línea antes de realizar la comparación. 
    ** uniq -u archivo.txt : Puedes utilizar la opción -u para mostrar solo las líneas únicas y eliminar las duplicadas.
    ** sort archivo.txt | uniq : Ordena el archivo con 'sort' para asegurarse de las lìneas duplicadas estèn contiguas.
* tee : se utiliza para leer la entrada estàndar y escribirla tanto en la salida estàndar como en uno o varios archivos.
    ** comando | tee archivo.txt : El uso más simple de tee es redirigir la salida de un comando a un archivo mientras la muestra en la terminal.
    **  comando | tee archivo1.txt archivo2.txt archivo3.txt : Puedes utilizar tee para guardar la salida en varios archivos a la vez. 
    ** comando | tee -a archivo.txt : Puedes utilizar la opción -a para anexar la salida a un archivo existente en lugar de reemplazarlo. 
    ** comando 2>&1 | tee archivo.txt >/dev/null : Puedes usar tee junto con redirecciones para guardar la salida en un archivo y redirigir la salida estándar a otro lugar.
    ** comando | tee archivo.txt | otro_comando : Puedes utilizar tee para guardar la salida en un archivo y también redirigirla a otro comando o tubería. 
    ** ./script.sh 2>&1 | tee log.txt : Puedes usar tee para guardar la salida completa de un script en un archivo.
* grep : Se utiliza para buscar patrones de texto en archivos o en la salida de otros comandos.
    ** grep "patrón" archivo.txt : El uso más simple de grep es buscar un patrón específico en un archivo o en la entrada proporcionada.
    ** grep -r "patrón" directorio/ : Puedes utilizar la opción -r o -R para buscar patrones de forma recursiva en directorios y subdirectorios. 
    ** grep -v "patrón" archivo.txt : Puedes utilizar la opción -v para mostrar líneas que no coincidan con el patrón. 
    ** grep -E "patrón1|patrón2" archivo.txt : grep admite expresiones regulares para realizar búsquedas más avanzadas. 
    ** grep -i "patrón" archivo.txt : Puedes utilizar la opción -i para realizar una búsqueda que ignore las diferencias entre mayúsculas y minúsculas. 
    ** grep -n "patrón" archivo.txt : Puedes utilizar la opción -n para mostrar los números de línea junto con las coincidencias.
    ** grep -c "patrón" archivo.txt : Puedes utilizar la opción -c para contar el número de coincidencias en lugar de mostrar las líneas coincidentes.
    ** grep --help : Puedes obtener información sobre el uso de grep y sus opciones utilizando la opción --help. 
* sort : Se utiliza para ordenar lìneas de texto en orden alfabético o nùmerico.
    ** sort archivo.txt : El uso más básico de sort es ordenar líneas de texto alfabéticamente en orden ascendente. 
    ** sort -n numeros.txt : Puedes utilizar la opción -n para ordenar líneas numéricamente en lugar de alfabéticamente. 
    ** sort -r archivo.txt : Puedes utilizar la opción -r para ordenar las líneas en orden descendente. 
    ** sort -k2 archivo.txt : Puedes utilizar la opción -k seguida de un número para especificar el campo por el cual deseas ordenar. 
    ** sort -f archivo.txt : Puedes utilizar la opción -f para realizar una clasificación que ignore las diferencias entre mayúsculas y minúsculas.
    ** sort -g numeros.txt : Puedes utilizar la opción -g para ordenar números teniendo en cuenta el valor numérico en lugar del orden lexicográfico. 
    ** sort -u archivo.txt : Puedes utilizar la opción -u para ordenar líneas y eliminar duplicados. 
    ** sort -t',' -k3 archivo.csv : Puedes utilizar la opción -t para especificar un carácter delimitador personalizado para separar campos en cada línea.
    ** sort archivo1.txt archivo2.txt archivo3.txt : Puedes proporcionar varios archivos como argumentos, y sort los ordenará juntos.
* cut : Se utiliza para extraer secciones especìficas de lìneas de texto de archivos o de la entrada estàndar.
    ** cut -d',' -f2 archivo.csv : El uso más básico de cut es recortar campos delimitados por un carácter específico. 
    ** cut -c1-5 archivo.txt : Puedes utilizar la opción -c para recortar caracteres específicos de cada línea.
    ** cut -b1-5 archivo.bin : Similar a -c, puedes utilizar la opción -b para recortar por bytes en lugar de caracteres. 
    ** cut -d',' -f3-5 archivo.csv : Puedes especificar un rango de caracteres o campos utilizando la opción -f o -c.
    ** cut -c2,4,6 archivo.txt : Puedes utilizar la opción -c para recortar campos basados en caracteres específicos en lugar de delimitadores fijos. 
    ** cut -d':,;' -f2 archivo.txt : Puedes especificar varios caracteres delimitadores utilizando la opción -d. 
    ** cut -d',' -f2- archivo.csv : Puedes utilizar la opción -f o -c junto con un signo - para mostrar el resultado inverso.
    ** cut --help : Puedes obtener información sobre el uso de cut y sus opciones utilizando la opción --help.
    ** ls -l | cut -c 41-44 : sirve para ver desde un espacio o caràcter definido.
* ps : se utiliza para mostrar informaciòn sobre los procesos en ejecuciòn en el sistema.
    ** ps : El uso más básico de ps es simplemente ejecutarlo sin opciones. Esto mostrará todos los procesos asociados con el usuario actual en la terminal.
    ** ps -e o ps -A : Para mostrar todos los procesos en el sistema, puedes utilizar la opción -e o -A.
    ** ps -l : Puedes utilizar la opción -l para obtener una salida más detallada que incluye información sobre la terminal, el estado, el uso de CPU y más.
    ** ps -u usuario  o ps -ux : Puedes utilizar la opción -u seguida del nombre de usuario para mostrar procesos específicos de ese usuario y la opcion 'ps -ux' nos da todos los procesos que se estàn ejecutando con nuestro usuario.
    ** ps -f o ps -ef : Puedes utilizar la opciòn '-ef' para mostrar todos los procesos en formato completo, que incluye informaciòn detallada de la lìnea de comandos y mas.
    ** ps --forest : Puedes utilizar la opción --forest para mostrar los procesos en forma de árbol, lo que facilita la visualización de las relaciones de los procesos.
    ** ps -g PGID : Puedes utilizar la opción -g seguida del ID del grupo de procesos (PGID) para mostrar procesos específicos de ese grupo.
    ** ps --help o : Puedes obtener información sobre el uso de ps y sus opciones utilizando la opción --help.
    ** ps -uxf : nos muestra todos los procesos del usuario en forma de àrbol jerarquico.
* pstree : Se utiliza para mostrar una representaciòn jeràrquica de los procesos en el sistema en forma de àrbol.
* sleep : Se utiliza en linux para suspender la ejecuciòn de un script o comando durante un perìodo de tiempo especìfico.
    ** sleep 5 : Este comando pausarà la ejecuciòn durante 5 segundos antes de continuar.
* renice : Se utiliza para cambiar la prioridad de ejecuciòn de un proceso en tiempo de ejecuciòn. No es comùnmente combinado con otros comandos.
    ** renice -n 10 -p PID : El uso básico de "renice" es proporcionar el número de prioridad deseado y el ID de proceso (PID) del proceso al que deseas cambiar la prioridad.
    ** renice -n 5 -g PGID : Puedes utilizar la opción "-g" seguida del número de prioridad deseado y el ID del grupo de procesos (PGID) para cambiar la prioridad de un grupo de procesos.
    ** renice -n -5 -u usuario : Puedes utilizar la opción "-u" seguida del nombre de usuario para cambiar la prioridad de todos los procesos pertenecientes a ese usuario.
    ** renice -p PID : Puedes utilizar la opción "-p" seguida del PID para mostrar la prioridad actual de un proceso sin realizar ningún cambio.
    ** renice --help : Puedes obtener información sobre el uso de "renice" y sus opciones utilizando la opción "--help".
* top : Se utiliza para monitoriar la actividad del sistema y ver informaciòn en tiempo real sobre los procesos en ejecuciòn, la carga del sistema y otros recursos. "top" es una herramienta interactiva y no se combina tìpicamente con otros comandos.
    ** top -d 2 : Puedes cambiar el intervalo de actualización de "top" para ajustar con qué frecuencia se actualiza la información. 
    ** top -U usuario : Puedes utilizar la opción -U seguida del nombre de usuario para mostrar solo los procesos de ese usuario.
    ** Cambiar la prioridad de actualización: Puedes cambiar la prioridad de actualización en tiempo real dentro de "top". Presiona "r" y luego ingresa el valor de prioridad deseado.
    ** Mostrar la ayuda: Puedes obtener información sobre el uso de "top" y las opciones disponibles presionando "h" mientras se ejecuta "top".
        *** Atajos de teclado comunes en top para interactuar:
            **** q: Salir de "top".
            **** k: Matar (terminar) un proceso. Debes ingresar el PID del proceso que deseas terminar.
            **** u: Mostrar solo los procesos de un usuario específico. Luego, ingresa el nombre de usuario.
            **** f: Mostrar o ocultar campos específicos.
            **** L: Mostrar o ocultar procesos de usuario.
            **** t: Mostrar o ocultar la barra de resumen de tareas.
            **** H: Mostrar o ocultar los encabezados de las columnas.
            **** W: Guardar la configuración actual en el archivo "~/.toprc".
            **** R: Invertir el orden de clasificación de la lista de procesos.
            **** c: Mostrar o ocultar la información sobre los comandos de los procesos.
            **** ?: Mostrar la página de ayuda incorporada de "top" con información sobre atajos de teclado.
* kill : Se utiliza para enviar señales a procesos en ejecuciòn para controlar su comportamiento. Aunque "kill" no se combina tìpicamente con otros comandos.
    ** kill PID : Si ejecutas "kill" sin especificar una señal, enviará la señal predeterminada SIGTERM al proceso especificado. Esta señal suele indicar al proceso que se cierre de manera ordenada.
    ** kill -s SIGKILL 12345  o kill -9 12345: Puedes especificar una señal específica utilizando la opción "-s" seguida del nombre de la señal o su número. Por ejemplo, para enviar la señal SIGKILL (que fuerza la terminación del proceso) al proceso con PID 12345.
    ** kill -9 PID : Para enviar la señal SIGKILL, que es una señal más fuerte y forzosa, puedes utilizar la opción "-9" (equivalente a SIGKILL). Esto se usa a menudo cuando un proceso no responde a señales menos agresivas.
    ** kill --help : Puedes obtener información sobre el uso de "kill" y las señales disponibles utilizando la opción "--help".
    ** kill -s SIGUSR1 PID : Puedes enviar señales de usuario personalizadas (por ejemplo, SIGUSR1 o SIGUSR2) utilizando sus números correspondientes o sus nombres. Esto es útil cuando un programa está diseñado para responder a señales específicas de usuario.
* jobs : Se utiliza para listar los trabajos en segundo plano que estàn asociados con la sesiòn actual de la terminal.
    ** bg %1 : Se utiliza para enviar un trabajo en segundo plano a ejecución en segundo plano si se encuentra en estado detenido. Puedes especificar un trabajo utilizando su número de trabajo o el símbolo %. 
    ** fg %2 : Se utiliza para traer un trabajo en segundo plano al primer plano y establecerlo como trabajo actual en ejecución. Al igual que con bg, puedes especificar el trabajo utilizando su número de trabajo o el símbolo %. 
    ** kill %3 : Aunque no es exclusivo de "jobs", el comando "kill" se utiliza para enviar señales a trabajos en segundo plano o en primer plano. Puedes especificar el proceso objetivo utilizando su número de trabajo o PID. 
        *** -l: Muestra información adicional sobre cada trabajo, incluyendo su estado y el comando asociado.
        *** -p: Muestra solo los números de proceso (PID) de los trabajos en lugar de mostrar información detallada.
        *** -n: Muestra solo los trabajos en segundo plano.
        *** -r: Muestra solo los trabajos en segundo plano que están en estado detenido.
* chmod : Se utiliza para cambiar los permisos de archivos y directorios.
        *** - : Quitar permisos.
        *** + : Otorgar permisos.
        *** a: Todos.
        *** u: El propietario del archivo.
        *** g: El grupo del archivo.
        *** o: Otros usuarios.
        *** r: Permiso de lectura(valor=4).
        *** w: Permiso de escritura(valor=2).
        *** x: Permiso de ejecución(valor=1).
    ** chmod -R 755 directorio : Si deseas cambiar permisos de un directorio y sus subdirectorios de manera recursiva, puedes usar la opción -R.
    ** chmod -a "user:usuario:rw-" archivo : Si tu sistema de archivos admite ACL, puedes utilizar la opciòn '-a' para modificar las ACL de un archivo o directorio.
    ** stat archivo : Para mostrar informaciòn sobre un archivo, incluidos los permisos de acceso.
* sudo chgrp grupo archivo : Para cambiar el grupo de un archivo a "grupo".
* sudo chown usuario archivo : Para cambiar el propietario de un archivo a "usuario".
* umask : Se utiliza para establecer o mostrar la màscara de permisos predeterminada que se aplica a los archivos y directorios recièn creados  en un sistema.
    ** umask 022 : Puedes utilizar "umask" seguido de una notación octal para establecer la máscara de permisos. Por ejemplo, para establecer una máscara que permita permisos completos al propietario y solo permisos de lectura a otros (umask 022).
        DIRECTORIO:
            *** Defecto :        777
            *** Restamos umask : 022
            *** Resultado =      755
        ARCHIVO:
            *** Defecto :        666
            *** Restamos umask : 022
            *** Resultado =      644
        ** umask : Puedes usar "umask" sin argumentos para mostrar la máscara de permisos actual.
    ** umask -S : Puedes utilizar la opción -S para mostrar la máscara de permisos en formato simbólico.
    
    


